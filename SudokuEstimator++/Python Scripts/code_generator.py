N = 4
M = 4
size = N * M

def output_update_domains_set(file, x, y):
    bx = M * int(x / M)
    by = N * int(y / N)
    bxe = bx + M
    bye = by + N

    file.write('bool Generated::update_domains_set_{}_{}(int domain_sizes[], int constraints[], int value) {{\n'.format(x, y))
    file.write('\tbool valid = true;\n')

    file.write('\n')
    file.write('\t// Update current row\n')

    for i in range(0,   x):    file.write('\tvalid &= update_constraint_set(domain_sizes, constraints, {}, {}, value);\n'.format(i, y))
    for i in range(x+1, size): file.write('\tvalid &= update_constraint_set(domain_sizes, constraints, {}, {}, value);\n'.format(i, y))

    file.write('\n')
    file.write('\t// Update current column\n')

    for j in range(0, y):    
        if j % N != 0: file.write('\tvalid &= update_constraint_set(domain_sizes, constraints, {}, {}, value);\n'.format(x, j))
    for j in range(y+1, size):
        if j % N != 0: file.write('\tvalid &= update_constraint_set(domain_sizes, constraints, {}, {}, value);\n'.format(x, j))

    file.write('\n')
    file.write('\t// Update current block\n')

    for j in range(by+1, y):
        for i in range(bx,  x):   file.write('\tvalid &= update_constraint_set(domain_sizes, constraints, {}, {}, value);\n'.format(i, j))
        for i in range(x+1, bxe): file.write('\tvalid &= update_constraint_set(domain_sizes, constraints, {}, {}, value);\n'.format(i, j))
    for j in range(y+1, bye):
        for i in range(bx,  x):   file.write('\tvalid &= update_constraint_set(domain_sizes, constraints, {}, {}, value);\n'.format(i, j))
        for i in range(x+1, bxe): file.write('\tvalid &= update_constraint_set(domain_sizes, constraints, {}, {}, value);\n'.format(i, j))

    file.write('\n')
    file.write('\treturn valid;\n')
    file.write('}\n\n')

def output_update_domains_reset(file, x, y):
    bx = M * int(x / M)
    by = N * int(y / N)
    bxe = bx + M
    bye = by + N

    file.write('void Generated::update_domains_reset_{}_{}(int domain_sizes[], int constraints[], int value) {{\n'.format(x, y))
    file.write('\t// Update current row\n')

    for i in range(0,   x):    file.write('\tupdate_constraint_reset(domain_sizes, constraints, {}, {}, value);\n'.format(i, y))
    for i in range(x+1, size): file.write('\tupdate_constraint_reset(domain_sizes, constraints, {}, {}, value);\n'.format(i, y))

    file.write('\n')
    file.write('\t// Update current column\n')

    for j in range(0, y): 
        if j % N != 0: file.write('\tupdate_constraint_reset(domain_sizes, constraints, {}, {}, value);\n'.format(x, j))
    for j in range(y+1, size):
        if j % N != 0: file.write('\tupdate_constraint_reset(domain_sizes, constraints, {}, {}, value);\n'.format(x, j))

    file.write('\n')
    file.write('\t// Update current block\n')

    for j in range(by+1, y):
        for i in range(bx,  x):   file.write('\tupdate_constraint_reset(domain_sizes, constraints, {}, {}, value);\n'.format(i, j))
        for i in range(x+1, bxe): file.write('\tupdate_constraint_reset(domain_sizes, constraints, {}, {}, value);\n'.format(i, j))
    for j in range(y+1, bye):
        for i in range(bx,  x):   file.write('\tupdate_constraint_reset(domain_sizes, constraints, {}, {}, value);\n'.format(i, j))
        for i in range(x+1, bxe): file.write('\tupdate_constraint_reset(domain_sizes, constraints, {}, {}, value);\n'.format(i, j))

    file.write('}\n\n')

with open('../Generated.h', 'w') as file:
    file.write('''// File generated by Python script, do not modify

typedef bool (* SetFunction)  (int domain_sizes[], int constraints[], int value);
typedef void (* ResetFunction)(int domain_sizes[], int constraints[], int value);

struct Generated {{
inline static constexpr int N = {N}; 
inline static constexpr int M = {M};

'''.format(N=N, M=M, size=size*size))

    for y in range(0, size):
        for x in range(0, size):
            file.write('static bool update_domains_set_{}_{}  (int domain_sizes[], int constraints[], int value);\n'.format(x, y, N, M))
            file.write('static void update_domains_reset_{}_{}(int domain_sizes[], int constraints[], int value);\n'.format(x, y, N, M))
            file.write('\n')

    file.write('inline static constexpr const SetFunction table_set[{}] = {{\n'.format(size * size))
    for y in range(0, size):
        for x in range(0, size):
            file.write('\tupdate_domains_set_{}_{},\n'.format(x, y))
    file.write('};\n')
    file.write('inline static constexpr const ResetFunction table_reset[{}] = {{\n'.format(size * size))
    for y in range(0, size):
        for x in range(0, size):
            file.write('\tupdate_domains_reset_{}_{},\n'.format(x, y))
    file.write('};\n')
    file.write('};\n')

with open('../Generated.cpp', 'w') as file:
    file.write('''// File generated by Python script, do not modify
#include "Generated.h"

// Method for updating the constraint at cell (i, j), associated with 'value' when SETTING the value
inline bool update_constraint_set(int domain_sizes[], int constraints[], int i, int j, int value) {{
    int index = i + j * {size};

    // If there were previously no constraints on this value, now there is one.
    // This means the domain size of the cell at (i, j) has shrunk by 1
    domain_sizes[index] -= !( constraints[index * {size} + value]++ ); 

    return domain_sizes[index] != 0;
}}

// Method for updating the constraint at cell (i, j), associated with 'value' when RESETTING the value
inline void update_constraint_reset(int domain_sizes[], int constraints[], int i, int j, int value) {{
    int index = i + j * {size};

    // If there was previously a constraint on this value, now there are none.
    // This means the domain size of the cell at (i, j) has increased by 1
    domain_sizes[index] += !( --constraints[index * {size} + value] );
}}

'''.format(size=size))

    for y in range(0, size):
        for x in range(0, size):
            output_update_domains_set(file, x, y)
            output_update_domains_reset(file, x, y)

print('File written successfully!')